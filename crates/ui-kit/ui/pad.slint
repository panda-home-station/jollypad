import { Theme } from "styles.slint";
import { VerticalBox, HorizontalBox } from "std-widgets.slint";
import { PadItem } from "types.slint";

export component PadGrid inherits FocusScope {
    in property <[PadItem]> items;
    callback item-clicked(string, string, string); // exec, name, app-id
    in-out property <int> selected-index: 0;
    in property <int> columns: 6;
    in property <bool> is-overview: false; // Add mode flag
    in property <bool> single-row: false; // Single row mode for expanded view
    in property <bool> hide-text: false; // Hide text label
    callback activate-selected();

    // Use a rectangle for background since FocusScope has no visual representation
    Rectangle {
        background: transparent;
    }
    
    // forward-focus: touch-handler; // No longer needed if PadGrid inherits FocusScope?
    // Actually, if PadGrid is a FocusScope, it can accept focus directly.
    // But we have a touch-handler inside. 
    // Let's keep the logic inside key-pressed handler on the root FocusScope (PadGrid itself).

    key-pressed(event) => {
        if (event.text == Key.UpArrow) { root.navigate-up(); return accept; }
        if (event.text == Key.DownArrow) { root.navigate-down(); return accept; }
        if (event.text == Key.LeftArrow) { root.navigate-left(); return accept; }
        if (event.text == Key.RightArrow) { root.navigate-right(); return accept; }
        if (event.text == Key.Return) { root.activate-selected(); return accept; }
        reject
    }
    
    // Auto-scroll calculation for single row
    property <length> item-w: (root.single-row) ? 220px : (root.width - (root.columns + 1) * 20px) / root.columns;
    property <length> item-h: (root.single-row) ? 220px : 180px;
    property <length> item-gap: 100px; // Increased gap for larger scale
    
    // Calculate target scroll position to keep selected item in view
    // Center the selected item: selected-x - width/2 + item-w/2
    property <length> target-viewport-x: root.single-row ? 
        clamp(-root.selected-index * (root.item-w + root.item-gap) + root.width / 2 - root.item-w / 2,
              root.width - (root.items.length * (root.item-w + root.item-gap) + root.item-gap), 0px)
        : 0px;

    Flickable {
        interactive: true;
        viewport-height: root.single-row ? root.height : (items.length / root.columns + 1) * 200px; 
        viewport-width: root.single-row ? (items.length * (root.item-w + root.item-gap) + root.item-gap) : root.width;
        
        viewport-x: root.single-row ? root.target-viewport-x : 0px;
        animate viewport-x { duration: 200ms; easing: cubic-bezier(0.2, 0.0, 0.0, 1.0); }
        
        for item[i] in items : Rectangle {
            // Scale simulation logic
            property <float> active-scale: (i == root.selected-index) ? 1.50 : 1.0; // Increased scale to 1.5
            animate active-scale { duration: 250ms; easing: cubic-bezier(0.2, 0.8, 0.2, 1.0); }

            width: root.item-w * active-scale;
            height: root.item-h * active-scale;
            
            // Adjust x and y to center the scaled item
            x: (root.single-row ? 
               (i * (root.item-w + root.item-gap) + root.item-gap) : 
               (mod(i, root.columns) * (root.item-w + 20px) + 20px)) - (self.width - root.item-w) / 2;
               
            y: (root.single-row ? 
               (parent.height - root.item-h) / 2 : 
               (floor(i / root.columns) * (root.item-h + 20px) + 20px)) - (self.height - root.item-h) / 2;
            
            background: (i == root.selected-index) ? Theme.card-hover : (touch.pressed ? Theme.card-hover : transparent);
            border-radius: Theme.border-radius;
            border-width: (i == root.selected-index) ? 2px : 0px;
            border-color: Theme.focus-color;
            
            // z: (i == root.selected-index) ? 100 : 1; // Removed due to compilation error
            
            touch := TouchArea {
                clicked => { root.item-clicked(item.exec, item.name, item.app-id); }
            }

            // Overview Mode: Vertical Layout with both Icon and Text
            if (root.is-overview && !root.hide-text) : VerticalLayout {
                padding: 8px;
                spacing: 8px;
                alignment: center;

                if (item.has-icon) : Image {
                    width: 64px;
                    height: 64px;
                    source: item.icon;
                    horizontal-alignment: center;
                }
                
                Text {
                    text: item.name;
                    color: Theme.text-color;
                    font-size: 14px;
                    wrap: word-wrap;
                    overflow: elide;
                    horizontal-alignment: center;
                    vertical-alignment: center;
                }
            }
            
            // Overview Mode (Icon Only / Hide Text): Manual Centering
            if (root.is-overview && root.hide-text && item.has-icon) : Image {
                width: 64px;
                height: 64px;
                source: item.icon;
                x: (parent.width - self.width) / 2;
                y: (parent.height - self.height) / 2;
            }

            // Home Mode: Standard Layout (Icon centered, or Text if no icon)
            if (!root.is-overview && item.has-icon) : Image {
                width: (root.single-row ? 180px : 128px) * parent.active-scale;
                height: (root.single-row ? 180px : 128px) * parent.active-scale;
                x: (parent.width - self.width) / 2;
                y: (parent.height - self.height) / 2;
                source: item.icon;
            }
            
            if (!root.is-overview && !item.has-icon) : Text {
                text: item.name;
                color: Theme.text-color;
                font-size: 24px * parent.active-scale;
                wrap: word-wrap;
                horizontal-alignment: center;
                vertical-alignment: center;
                width: parent.width - 16px;
                height: parent.height - 16px;
                x: 8px;
                y: 8px;
            }
        }
    }
    
    activate-selected => {
        if (items.length > 0) {
            let idx0 = root.selected-index;
            let idx1 = (idx0 < 0) ? 0 : idx0;
            let last = items.length - 1;
            let idx = (idx1 > last) ? last : idx1;
            root.item-clicked(items[idx].exec, items[idx].name, items[idx].app-id);
        }
    }

    public function navigate-up() {
        if (!root.single-row) {
            if (root.selected-index >= root.columns) {
                root.selected-index -= root.columns;
            }
        }
    }

    public function navigate-down() {
        if (!root.single-row) {
            if (root.selected-index + root.columns < root.items.length) {
                root.selected-index += root.columns;
            }
        }
    }

    public function navigate-left() {
        debug("navigate-left: index=" + root.selected-index + ", items=" + root.items.length);
        if (root.selected-index > 0) {
            root.selected-index -= 1;
        } else {
            debug("navigate-left: blocked at start");
        }
    }

    public function navigate-right() {
        debug("navigate-right: index=" + root.selected-index + ", items=" + root.items.length);
        if (root.selected-index < root.items.length - 1) {
            root.selected-index += 1;
        } else {
            debug("navigate-right: blocked at end");
        }
    }
}
